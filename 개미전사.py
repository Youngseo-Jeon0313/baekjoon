#배열이 있을 때 인접한 것은 고르지 못하고, 
#그렇게 꾸준히 배열을 다 점프점프하던가 점프점프점프해서
#더해서 얻는 식량의 최대값
#0번째 까지의 최대? 1번째 까지의 최대? ... 이런 식으로

#i-1 i-2까지
#한 칸 이상 떨어진 식량창고는 항상 털 수 있으므로 (i-3)번째 이하는 고려할 필요 없다.

n= int(input())
array = list(map(int, input().split()))

d=[0]*100

d[0] = array[0]
d[1] = max(array[0], array[1]) #둘 중 최대가 되는 것으로 고르기 왜? 그 때까지 최대가 되는 합은 둘 중 하나를 고르는 거랑 똑같으니까
for i in range(2, n): #그 다음부터는 전과 전전으로 파악
    d[i] = max(d[i-1], d[i-2] + array[i]) #i-1번째를 왜 비교하냐면 그게 최초 최대일수도 있으니까
    #그 다음 d[i-2] + array[i] 는 지금까지 더한 것 + 바로 전 꺼 더한거

print(d[n-1])

'''
10
1 10 1 1 10 1 1 1 1 10   31

d에는
1 10 
'''