##DP
재귀함수_피보나치 수열로 생각하는 것이 가장 간단하다.
우리가 만약 f(7)을 찾고 싶을 때 우리는 f(6), f(5)가 필요하다. 그리고 다시 또 f(6)을 찾고 싶을 때는 f(5), f(4)가 필요하다. 이 때 또 f(5)를 찾지 않고 이미 찾았던 거에서 꺼내서 쓰는 거다.
-top down : 찾으러 밑으로 쭉쭉 가기
-bottom up : 아예 1부터 .. 해서 fibo수열을 직접 만들어버리기

##이분탐색


※
1.이분탐색 진행시 주어진 배열을 정렬되어 있어야 한다.
2.무한 루프에 빠지지 않게 mid값을 정해야 한다.

※ 스택, 큐, 덱, 우선순위 큐
힙에 요소를 추가할 때 항상 특정 지점에 추가된다는 점에 유의하자!
bubble하면서 위에 있는 것들과 위치가 switch된다.

힙 구성 과정
case1. 원소를 하나씩 추가할 때
1. 현재 들어올 노드를 우선순위가 가장 낮다고 가정한 후, 트리의 맨 마지막 위치에 저장
2. 부모 노드와 비교해 자신이 더 우선순위가 높다면 부모노드와 자리를 바꾼다. 낮다면 다시 1로 돌아감
3. 만약 트리의 루트라면 1번으로 돌아간다.

case2. 한꺼번에 넣고 작업
1. 우선순위에 상관없이 배열 내 원소들을 트리에 넣어둔다.
2. 모든 원소를 기준으로 case1의 힙 생성 알고리즘을 적용하면 된다.

※다익스트라
-BFS에 가중치 개념이 추가된 거라고 생각하면 될 듯
<사전작업>
1. dist[i] : 시작 노드에서 i번 노드까지의 최단거리를 저장하는 배열
-> 우선 모두 나올 수 없는 큰 수로 초기화해둔다. ex) 987654321, 10e9
->단 dist[시작노드]=0으로 만들어둔다.
2. v[s]={e,cost}: 시작점이 s이고 도착점이 e이며, 가중치가 cost인 edge
->인접리스트에 가중치를 추가한 모양

※그래프 이론
정점(node)-파란 원
간선(edge)-정점을 잇는 선(단방향 / 양방향으로 나뉜다.)
차수(degree)-어떤 정점에 이어져있는 간선들의 개수
사이클(cycle)-어떤 정점에서 주죽 이어져서 다시 자기자신으로
경로-뭐..생각에 따라 무한개가 될 수도 있는 것!
그래프 표현 방법?-인접 행렬/인접리스트 방법